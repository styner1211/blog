# 카프카

> 데이터를 활요하기 위해서는, 데이터를 생성하는 소스 어플리케이션과 데이터가 최종 적재되는 타겟 어플리케이션을 연결해야하는데, 시간이 지날 수록 복잡도가 증가하면서, 소스 / 타겟 어플리케이션의 갯수가 점점 많아지고, 데이터 파이프라인 관리가 어려워짐

> 한 곳에 모아 처리할 수 있다.

- fault tolerent (고가용성): 서버 장애 시 손실없이 복구
- 낮은 지연(latency)과 높은 처리량(throughput)


## 카프카의 특징
- 높은 처리량
  - 프로듀셔가 브로커로 데이터를 보낼 때, 브로커로부터 컨슈머가 데이터를 받을 때 배치 단위로 전송 가능, 네트워크 비용을 주림
  - 파티션 갯수 만큼 컨슈머 갯수를 늘려 데이터 처리량을 늘릴 수 있음
- 확장성
  - 카프카 클러스터( = 여러개의 브로커)의 scale-out
- 영속성
  - 전송받은 데이터를 파일 시스템에 저장
  - 운영체제 레벨에서 파일 I/O 성능 향상을 위해 페이지 캐시(page cache) 영역을 메모리에 따로 생성하여 사용
- 고가용성
  - 카프카 클러스터는 3개 이상의 서버(브로커)로 운영
  - 다른 브로커에도 데이터 복제 (replication)


## 카프카의 스트림 데이터를 배치 데이터로 활용
- 카프카의 레코드는 timestamp를 남김
- 일종의 스냅샷 데이터 처럼 배치 데이터로 표현 가능


## 프로듀서
- 토픽의 파티션으로 데이터를 보냄
- 배치 형태로 보내어 네트워크 비용을 줄일 수 있음

## 토픽
> 카프카 클러스터 = 여러개의 브로커
- 1개 이상의 파티션을 가질 수 있음
  - 여러개의 파티션은 데이터를 병렬 처리를 가능하게 함
  - 파티션 갯수만큼 컨슈머 개수를 늘려 데이터 처리량을 늘릴 수 있음
- 파티션: 일종의 queue

## 컨슈머
- 토픽의 파티션으로 부터 데이터를 가저감
- 토픽의 파티션으로 부터 데이터를 가져가도 데이터는 삭제되지 않음



### 메시지 브로커

데이터를 보내고, 처리하고, 삭제한다.

레디스 큐, 레빗엠큐



### 이벤트 브로커
1. 이벤트 또느 메시지라 불리는 레코드를 딱 하나만 관리, 인덱스를 통해 개별 엑세스를 관리
2. 업무상 필요한 시간동안 이벤트를 보전 할 수 있다.

이벤트 브로커의 큐에 저장 (마치 DB에 저장하듯이)

단일 진실 공급원
장애가 발생했을 때 장애가 일어난 지점부터 처리 가능
많은 양의 실시간 데이터를 효과적으로 처리할 수 있음
이벤트 기반 마이크로 서비스 아키텍쳐에서 중요한 역할

카프카. 키네시스