{"pageProps":{"mappings":[{"header":{"label":"연구","path":"00.research","md":"","preview":true,"sub":[{"label":"베이지안 추론","path":"bayesian-inference","md":"","preview":true,"sub":[{"label":"Coin Tossing","path":"coin-tossing","md":"","preview":true,"sub":[],"img":"/assets/research/bayesian-inference/coin-tossing/coin-tossing.jpg","snippet":"동전을 던졌을 때, 앞면이 나올 확률을 데이터에 기반하여 추정해보자","depth":2},{"label":"Curve Fitting","path":"curve-fitting","md":"","preview":true,"sub":[],"img":"/assets/research/bayesian-inference/curve-fitting/curve-fitting.JPG","snippet":"가지 중요한 개념을 설명하기에 앞서, 간단한 회귀(Regression) 문제를 소개해 보도록 하겠다.","depth":2},{"label":"Gibbs Sampling","path":"gibbs-sampling","md":"","preview":true,"sub":[],"img":"/assets/study/inverse-transform-sampling/Inverse_Transform_Sampling_Example.gif","snippet":"Gibbs Sampling을 구현하기위해 사용한 Inverse Transform Sampling 기법을 소개하면서 실질적인 구현 방법을 먼저 소개하고, 이론적인 배경은 나중에 업데이트 할 예정이다.","depth":2},{"label":"Variational Inference","path":"variational-inference","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"Inference는 [Bayeisan Inference](/docs/research/bayesian-inference)에서 적용되는 테크닉으로 개인적으로는 상당히 공부하기 어려웠던 것 중 하나여서 시간을 내어 정리해 보려고 한다.","depth":2}],"img":"/barcode.png","snippet":"Inference를 설명하기에 앞서 다음과 같은 순서로 각 개념을 이해하는 것이 중요하다.","depth":1},{"label":"가우시안 혼합 모델","path":"gaussian-mixture-model","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":1},{"label":"K-means Clustering","path":"k-means","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"K-means 알고리즘은 Gaussian Mixture Model의 특별한 경우이다. 그리고 EM 알고리즘의 Expectation 단계와 Maximazation 단계를 거쳐 학습하는 과정을 거친다.","depth":1},{"label":"Multi-Armed Bandit","path":"multi-armed-bandit","md":"","preview":true,"sub":[],"img":"/assets/research/multi-armed-bandit/mab.JPG","snippet":"여러대의 슬롯 머신이 있다고 하자. 그리고 일확천금을 위해서 어떤 사람이 슬롯 머신을 여기 저기서 당기고 있다. 이때 이 사람이 수익을 극대화 하는 방법이 있을까?","depth":1},{"label":"PageRank","path":"pagerank","md":"","preview":true,"sub":[],"img":"/assets/research/pagerank/pagerank.png","snippet":"상당히 직관적이고 간단하게 이해할 수 있는 개념이지만 그 이면을 들여다 보면 공부할 만한 사실들이 상당히 많이 있다. 그 중 중요하다고 생각하는 부분들에 대해서 소개하려고 한다.","depth":1},{"label":"추천 시스템","path":"recommendation-system","md":"","preview":true,"sub":[{"label":"컨텐츠 기반 알고리즘","path":"contents","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2},{"label":"Matrix Factorization","path":"matrix-factorization","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"Factorization은 추천 시스템에서 협업 필터링(Collaborative Filtering) 알고리즘에 속한다. 아이디어는 상당히 간단한데 User와 Item을 행과 열로 가진 Matrix 분해햐여 User와 Item을 low dimensional latent space에 사상 시키는 방법이다. 이를 위해 아랴와 같이 크게 두가지 방식으로 User-Item Matrix를 Decomposition 할 수 있다.","depth":2},{"label":"모델 기반 협업 필터링","path":"model","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2},{"label":"neighbor","path":"neighbor","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2}],"img":"/barcode.png","snippet":"","depth":1},{"label":"Stochastic Process","path":"stochastic-process","md":"","preview":true,"sub":[{"label":"디리클레 프로세스","path":"dirichlet-process","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2},{"label":"가우시안 프로세스","path":"gaussian-process","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2},{"label":"혹스 프로세스","path":"hawkes-process","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2},{"label":"포아송 프로세스","path":"poisson-process","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2}],"img":"/barcode.png","snippet":"Stochastic Process란, Random Variable(확률 변수) 혹은 function의 collection을 의미한다.","depth":1},{"label":"Singular Value Decomposition","path":"svd","md":"","preview":true,"sub":[],"img":"/assets/research/svd/axis.JPG","snippet":"Singular Value Decomposition (이하 SVD)는 Eigendecomposition의 일반화된 형태이므로 먼저 Eigendecompositon에 대해 정리해 본다.","depth":1},{"label":"Topic Model","path":"topic-modeling","md":"","preview":true,"sub":[{"label":"Adversarial-neural Event Model","path":"aem","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2},{"label":"Correlated Topic Model","path":"ctm","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2},{"label":"Gaussain LDA","path":"glda","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2},{"label":"Hierarchical Dirichlet Process","path":"hdp","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"LDA의 Non-parametric 버전으로 토픽 갯수 K를 지정하지 않아도 되는 더 일반적인 모델","depth":2},{"label":"Latent Dirichlet Allocation","path":"lda","md":"","preview":true,"sub":[],"img":"/assets/research/topic_modeling/lda/dist_desc.JPG","snippet":"LDA는 임의의 문서를 K개의 토픽 분포로 표현하고, 각 토픽은 V개의 단어 분포로 표현하는 모델이다.","depth":2},{"label":"Latent Event Model","path":"lem","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2}],"img":"/barcode.png","snippet":"토픽 모델이 뭔지 정리해보자","depth":1},{"label":"Variational AutoEncoder","path":"variational-autoencoder","md":"","preview":true,"sub":[],"img":"/assets/research/variational-autoencoder/ae-vae.png","snippet":"","depth":1}],"img":"/barcode.png","snippet":"공부했던 것들 중에, 생각할 것들이 많았던 것들을 정리하고 있다.","depth":0},"side_bar":[{"label":"베이지안 추론","path":"bayesian-inference","md":"","preview":true,"sub":[{"label":"Coin Tossing","path":"coin-tossing","md":"","preview":true,"sub":[],"img":"/assets/research/bayesian-inference/coin-tossing/coin-tossing.jpg","snippet":"동전을 던졌을 때, 앞면이 나올 확률을 데이터에 기반하여 추정해보자","depth":2},{"label":"Curve Fitting","path":"curve-fitting","md":"","preview":true,"sub":[],"img":"/assets/research/bayesian-inference/curve-fitting/curve-fitting.JPG","snippet":"가지 중요한 개념을 설명하기에 앞서, 간단한 회귀(Regression) 문제를 소개해 보도록 하겠다.","depth":2},{"label":"Gibbs Sampling","path":"gibbs-sampling","md":"","preview":true,"sub":[],"img":"/assets/study/inverse-transform-sampling/Inverse_Transform_Sampling_Example.gif","snippet":"Gibbs Sampling을 구현하기위해 사용한 Inverse Transform Sampling 기법을 소개하면서 실질적인 구현 방법을 먼저 소개하고, 이론적인 배경은 나중에 업데이트 할 예정이다.","depth":2},{"label":"Variational Inference","path":"variational-inference","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"Inference는 [Bayeisan Inference](/docs/research/bayesian-inference)에서 적용되는 테크닉으로 개인적으로는 상당히 공부하기 어려웠던 것 중 하나여서 시간을 내어 정리해 보려고 한다.","depth":2}],"img":"/barcode.png","snippet":"Inference를 설명하기에 앞서 다음과 같은 순서로 각 개념을 이해하는 것이 중요하다.","depth":1},{"label":"가우시안 혼합 모델","path":"gaussian-mixture-model","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":1},{"label":"K-means Clustering","path":"k-means","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"K-means 알고리즘은 Gaussian Mixture Model의 특별한 경우이다. 그리고 EM 알고리즘의 Expectation 단계와 Maximazation 단계를 거쳐 학습하는 과정을 거친다.","depth":1},{"label":"Multi-Armed Bandit","path":"multi-armed-bandit","md":"","preview":true,"sub":[],"img":"/assets/research/multi-armed-bandit/mab.JPG","snippet":"여러대의 슬롯 머신이 있다고 하자. 그리고 일확천금을 위해서 어떤 사람이 슬롯 머신을 여기 저기서 당기고 있다. 이때 이 사람이 수익을 극대화 하는 방법이 있을까?","depth":1},{"label":"PageRank","path":"pagerank","md":"","preview":true,"sub":[],"img":"/assets/research/pagerank/pagerank.png","snippet":"상당히 직관적이고 간단하게 이해할 수 있는 개념이지만 그 이면을 들여다 보면 공부할 만한 사실들이 상당히 많이 있다. 그 중 중요하다고 생각하는 부분들에 대해서 소개하려고 한다.","depth":1},{"label":"추천 시스템","path":"recommendation-system","md":"","preview":true,"sub":[{"label":"컨텐츠 기반 알고리즘","path":"contents","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2},{"label":"Matrix Factorization","path":"matrix-factorization","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"Factorization은 추천 시스템에서 협업 필터링(Collaborative Filtering) 알고리즘에 속한다. 아이디어는 상당히 간단한데 User와 Item을 행과 열로 가진 Matrix 분해햐여 User와 Item을 low dimensional latent space에 사상 시키는 방법이다. 이를 위해 아랴와 같이 크게 두가지 방식으로 User-Item Matrix를 Decomposition 할 수 있다.","depth":2},{"label":"모델 기반 협업 필터링","path":"model","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2},{"label":"neighbor","path":"neighbor","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2}],"img":"/barcode.png","snippet":"","depth":1},{"label":"Stochastic Process","path":"stochastic-process","md":"","preview":true,"sub":[{"label":"디리클레 프로세스","path":"dirichlet-process","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2},{"label":"가우시안 프로세스","path":"gaussian-process","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2},{"label":"혹스 프로세스","path":"hawkes-process","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2},{"label":"포아송 프로세스","path":"poisson-process","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2}],"img":"/barcode.png","snippet":"Stochastic Process란, Random Variable(확률 변수) 혹은 function의 collection을 의미한다.","depth":1},{"label":"Singular Value Decomposition","path":"svd","md":"","preview":true,"sub":[],"img":"/assets/research/svd/axis.JPG","snippet":"Singular Value Decomposition (이하 SVD)는 Eigendecomposition의 일반화된 형태이므로 먼저 Eigendecompositon에 대해 정리해 본다.","depth":1},{"label":"Topic Model","path":"topic-modeling","md":"","preview":true,"sub":[{"label":"Adversarial-neural Event Model","path":"aem","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2},{"label":"Correlated Topic Model","path":"ctm","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2},{"label":"Gaussain LDA","path":"glda","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2},{"label":"Hierarchical Dirichlet Process","path":"hdp","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"LDA의 Non-parametric 버전으로 토픽 갯수 K를 지정하지 않아도 되는 더 일반적인 모델","depth":2},{"label":"Latent Dirichlet Allocation","path":"lda","md":"","preview":true,"sub":[],"img":"/assets/research/topic_modeling/lda/dist_desc.JPG","snippet":"LDA는 임의의 문서를 K개의 토픽 분포로 표현하고, 각 토픽은 V개의 단어 분포로 표현하는 모델이다.","depth":2},{"label":"Latent Event Model","path":"lem","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":2}],"img":"/barcode.png","snippet":"토픽 모델이 뭔지 정리해보자","depth":1},{"label":"Variational AutoEncoder","path":"variational-autoencoder","md":"","preview":true,"sub":[],"img":"/assets/research/variational-autoencoder/ae-vae.png","snippet":"","depth":1}]},{"header":{"label":"개발","path":"01.development","md":"","preview":true,"sub":[{"label":"엘라스틱서치","path":"elasticsearch","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"사용했던 것들을 정리해보자.","depth":1},{"label":"개발 환경 구축","path":"env","md":"","preview":true,"sub":[{"label":"code-server","path":"code-server","md":"","preview":true,"sub":[],"img":"/assets/development/env/code-server/code-server.png","snippet":"+ ubuntu 20.04","depth":2}],"img":"/barcode.png","snippet":"","depth":1},{"label":"명령어 기록","path":"etc","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"sh","depth":1},{"label":"하둡","path":"hadoop","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":1},{"label":"java","path":"java","md":"","preview":true,"sub":[{"label":"자바의 비동기 기술","path":"async","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"Future","depth":2}],"img":"/barcode.png","snippet":"","depth":1},{"label":"쿠버네티스","path":"k8s","md":"","preview":true,"sub":[{"label":"쿠버네티스 설치","path":"installation","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"집에 놀고 있는 리눅스 머신에 K8S를 설치 해보자","depth":2}],"img":"/barcode.png","snippet":"","depth":1},{"label":"메시지 브로커","path":"kafka","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"보내고, 처리하고, 삭제한다.","depth":1},{"label":"코틀린","path":"kotlin","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":1},{"label":"루씬","path":"lucene","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"거의 Elasticsearch를 이용해서 프로젝트를 진행하지만, 검색이 필요한 경우 Lucene을 이용해서 개발하는 경우가 많았던 것 같다. JAVA에 Lucence 의존성만 추가하면 뭔가 가볍게 시작할 수 있었기 때문인데 점점 기능이 복잡해 질 수록 Elasticsearch가 얼마나 잘 만들어져 있는 것인가를 느끼고 있다. 그래도 Elasticsearch는 Lucence을 가져다 쓰는거니까 먼저 간단한 것 부터 정리해 볼 계획이다.","depth":1},{"label":"리액트","path":"react","md":"","preview":true,"sub":[{"label":"package.json","path":"package-json","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"dependencies vs devDependencies","depth":2},{"label":"react-snap으로 정적페이지 빌드","path":"react-snap","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"Basic usage with create-react-app","depth":2},{"label":"GitHub Pages에 SPA","path":"spa-github-pages","md":"","preview":true,"sub":[],"img":"/assets/development/react/spa-github-pages/github-pages-404.JPG","snippet":"1. 문제 상황","depth":2}],"img":"/assets/development/react/react-app.png","snippet":"React 개발 환경 구축","depth":1},{"label":"스프링 부트","path":"spring-boot","md":"","preview":true,"sub":[{"label":"Spring Boot에서 HTTPS 적용","path":"https","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"Certificate 만들기","depth":2},{"label":"Maven에서 Spring Boot 설정","path":"maven-support","md":"","preview":true,"sub":[],"img":"/assets/development/spring-boot/maven-support/multi-module.JPG","snippet":"Maven multi-module 프로젝트에서 Spring Boot Application을 Maven Dependency로 Import하기","depth":2}],"img":"/barcode.png","snippet":"","depth":1},{"label":"웹플럭스","path":"webflux","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":1}],"img":"/barcode.png","snippet":"","depth":0},"side_bar":[{"label":"엘라스틱서치","path":"elasticsearch","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"사용했던 것들을 정리해보자.","depth":1},{"label":"개발 환경 구축","path":"env","md":"","preview":true,"sub":[{"label":"code-server","path":"code-server","md":"","preview":true,"sub":[],"img":"/assets/development/env/code-server/code-server.png","snippet":"+ ubuntu 20.04","depth":2}],"img":"/barcode.png","snippet":"","depth":1},{"label":"명령어 기록","path":"etc","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"sh","depth":1},{"label":"하둡","path":"hadoop","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":1},{"label":"java","path":"java","md":"","preview":true,"sub":[{"label":"자바의 비동기 기술","path":"async","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"Future","depth":2}],"img":"/barcode.png","snippet":"","depth":1},{"label":"쿠버네티스","path":"k8s","md":"","preview":true,"sub":[{"label":"쿠버네티스 설치","path":"installation","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"집에 놀고 있는 리눅스 머신에 K8S를 설치 해보자","depth":2}],"img":"/barcode.png","snippet":"","depth":1},{"label":"메시지 브로커","path":"kafka","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"보내고, 처리하고, 삭제한다.","depth":1},{"label":"코틀린","path":"kotlin","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":1},{"label":"루씬","path":"lucene","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"거의 Elasticsearch를 이용해서 프로젝트를 진행하지만, 검색이 필요한 경우 Lucene을 이용해서 개발하는 경우가 많았던 것 같다. JAVA에 Lucence 의존성만 추가하면 뭔가 가볍게 시작할 수 있었기 때문인데 점점 기능이 복잡해 질 수록 Elasticsearch가 얼마나 잘 만들어져 있는 것인가를 느끼고 있다. 그래도 Elasticsearch는 Lucence을 가져다 쓰는거니까 먼저 간단한 것 부터 정리해 볼 계획이다.","depth":1},{"label":"리액트","path":"react","md":"","preview":true,"sub":[{"label":"package.json","path":"package-json","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"dependencies vs devDependencies","depth":2},{"label":"react-snap으로 정적페이지 빌드","path":"react-snap","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"Basic usage with create-react-app","depth":2},{"label":"GitHub Pages에 SPA","path":"spa-github-pages","md":"","preview":true,"sub":[],"img":"/assets/development/react/spa-github-pages/github-pages-404.JPG","snippet":"1. 문제 상황","depth":2}],"img":"/assets/development/react/react-app.png","snippet":"React 개발 환경 구축","depth":1},{"label":"스프링 부트","path":"spring-boot","md":"","preview":true,"sub":[{"label":"Spring Boot에서 HTTPS 적용","path":"https","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"Certificate 만들기","depth":2},{"label":"Maven에서 Spring Boot 설정","path":"maven-support","md":"","preview":true,"sub":[],"img":"/assets/development/spring-boot/maven-support/multi-module.JPG","snippet":"Maven multi-module 프로젝트에서 Spring Boot Application을 Maven Dependency로 Import하기","depth":2}],"img":"/barcode.png","snippet":"","depth":1},{"label":"웹플럭스","path":"webflux","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":1}]},{"header":{"label":"아무거나 정리","path":"02.study","md":"","preview":true,"sub":[{"label":"Chi-Square Test","path":"chi-square-test","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"검정은 하나 이상의 카테고리에서 관측된 빈도와 기대되는 빈도가 통계적으로 유의하게 다른지 검증하는 기법으로, 카이 제곱 분포에 기초한 통계적 가설 검정 방법이다.","depth":1},{"label":"HTTPS와 공개 키 암호 방식","path":"crypto","md":"","preview":true,"sub":[],"img":"/assets/study/crypto/https.png","snippet":"그린 그림인지 모르겠지만 가장 쉽게 잘 설명해주신 것 같다.","depth":1},{"label":"NumPy","path":"numpy","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"np.array","depth":1},{"label":"P-value","path":"p-value","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":1},{"label":"pandas","path":"pandas","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":1},{"label":"PyTorch","path":"pytorch","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":1}],"img":"/barcode.png","snippet":"궁금해서 찾아본 것, 알고 있었는데 까먹고 있었던 것, 생각 날 때마다 정리해보자.","depth":0},"side_bar":[{"label":"Chi-Square Test","path":"chi-square-test","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"검정은 하나 이상의 카테고리에서 관측된 빈도와 기대되는 빈도가 통계적으로 유의하게 다른지 검증하는 기법으로, 카이 제곱 분포에 기초한 통계적 가설 검정 방법이다.","depth":1},{"label":"HTTPS와 공개 키 암호 방식","path":"crypto","md":"","preview":true,"sub":[],"img":"/assets/study/crypto/https.png","snippet":"그린 그림인지 모르겠지만 가장 쉽게 잘 설명해주신 것 같다.","depth":1},{"label":"NumPy","path":"numpy","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"np.array","depth":1},{"label":"P-value","path":"p-value","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":1},{"label":"pandas","path":"pandas","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":1},{"label":"PyTorch","path":"pytorch","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":1}]},{"header":{"label":"토이 프로젝트","path":"03.project","md":"","preview":true,"sub":[{"label":"CNN 기반 형태소 분석기","path":"cnn-morph","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":1}],"img":"/barcode.png","snippet":"","depth":0},"side_bar":[{"label":"CNN 기반 형태소 분석기","path":"cnn-morph","md":"","preview":true,"sub":[],"img":"/barcode.png","snippet":"","depth":1}]}],"post":"# Coin Tossing (동전 던지기)\r\n\r\n> 동전을 던졌을 때, 앞면이 나올 확률을 데이터에 기반하여 추정해보자\r\n\r\n<img width=\"180\" src=\"/assets/research/bayesian-inference/coin-tossing/coin-tossing.jpg\" />\r\n\r\n동전을 던졌을 때, 앞면이 나올 확률은 얼마일까? 우리는 경험적으로 앞면이 나올 확률은 $$\\cfrac 1 2$$이라고 알고 있다.\r\n\r\n여기서 경험적으로 알고 있다라는 것은 데이터에 기반한 것이다라고 생각할 수 있고, 이것은 분명 많은 관측치(Observation)를 통해서 추정해 낸 것일 것이다. 이러한 활동이 사실 기계 학습(Machine Learning)에서 하는 것과 정확하게 일치한다고 할 수 있다.\r\n\r\n다시 본론으로 돌아와서, 다음의 상황을 가정해 보자.\r\n\r\n동전 한 개가 주어져 있고, 동전을 던졌을 때, 동전의 앞면이 나올 확률 $$P(H)$$이 얼마일 지 추정해 보고 싶다. 이를 위해서는 먼저 주어져 있는 동전을 여러번 던져보는 시뮬레이션?이 필요하다.\r\n\r\n예를 들어 동전을 3번 던져 보고 다음과 같은 결과를 얻었다고 하자. 이때 각 시행은 i.i.d. (independent and identically distributed)라고 가정한다.\r\n\r\n$$\r\n\\begin{aligned}\r\nH, H, T\r\n\\end{aligned}\r\n$$\r\n\r\n- $$H$$: 동전 앞면\r\n- $$T$$: 동전 뒷면\r\n\r\n위의 관측치들을 토대로, 일반적으로는 동전 앞면이 나올 확률은 $$P(H) = \\cfrac 2 3$$ 라고 판단할 수 있다. (물론 동전 던지기 시행 횟수가 3번은 매우 적은 숫자이기는 하다.)\r\n\r\n> 위와 같은 해석이 앞으로 설명할 Maximum Likelihood Estimation 방식이라고 할 수 있다.\r\n\r\n이것을 좀 더 formal하게 설명 해 본다면,\r\n\r\n$$\r\n\\begin{aligned}\r\nP(H) &= \\mu \\\\ P(T) &= 1-\\mu\r\n\\end{aligned}\r\n$$\r\n\r\n동전 앞/뒤면이 나올 확률을 각 각 위와 같이 표현할 수 있고, 이때 이 확률 분포는 베르누이 분포(Bernoulli Distribution)를 따른다고 볼 수 있다. 즉, 동전을 던졌을 때 나오는 관측값(ex: $$H, H, T$$) 들은 베르누이 분포로 부터의 샘플이라고 생각할 수 있다.\r\n\r\n따라서, 동전 던지기의 반복된 시행으로부터 얻은 데이터 $$D = \\lbrace x_1, x_2, ... x_N \\rbrace$$, $$x_i=1$$(앞면) 또는 0(뒷면) 라고 할 때,\r\n\r\n데이터의 Likelihood는 다음과 같이 계산된다.\r\n\r\n$$\r\n\\begin{aligned}\r\nP(D|\\mu)\r\n=\r\n\\displaystyle\\prod_{n=1}^{N} p(x_n|\\mu)\r\n=\r\n\\displaystyle\\prod_{n=1}^{N} \\mu^{x_n}(1-\\mu)^{1-x_n}\r\n\\end{aligned}\r\n$$\r\n\r\n<figcaption align=\"center\">\r\n  <b>식 1: Likelihood</b>\r\n</figcaption>\r\n\r\n위 식을 좀 더 고민해 볼 필요가 있는게, 지금 내가 가지고 있는 \"동전\"이 얼마나 앞면을 잘 나오게 하는 동전인가에 대한 모델 관점에서 바라본다면,\r\n\"동전 모델\"을 설명하는 중요한 파라미터는 베르누이 분포의 파라미터인 $$\\mu$$라고 할 수 있다.\r\n\r\n즉, 기계학습의 관점에서는 주어진 데이터($$D$$)를 통해서 모델의 파라미터인 $$\\mu$$를 찾는 것이 목표라고 할 수 있다.\r\n\r\n이때, 모델 파라미터를 찾는 접근 방식을 다음의 세가지로 구분 할 수 있는데,\r\n\r\n1. Maximum Likelihood Estimation (MLE)\r\n2. Maximum a Posteriori (MAP)\r\n3. Bayesian Inference\r\n\r\n하나씩 어떤 특성이 있는지 알아보도록 하겠다.\r\n\r\n## Maximum Likelihood Estimation (MLE)\r\n\r\n지금 설명하는 MLE 방식은, 대부분의 전통적인 기계학습 모델 뿐만 아니라, 현재 많이 쓰이고 있는 뉴럴 네트워크 모델의 weight 혹은 parameter 값을 구하는데 사용되는 가장 일반적인 방법이다.\r\n\r\n위 동전 던지기 상황에서 Maximum Likelihood Estimation 방식으로 파라미터를 추정해 본다면, 말 그대로 위 식 1 likehood를 최대로 하는 $$\\mu$$를 찾는 문제가 된다.\r\n\r\n$$\r\n\\begin{aligned}\r\n\\mu_{MLE} = \\argmax_{\\mu} P(D|\\mu)\r\n\\end{aligned}\r\n$$\r\n\r\n이는 식 1에 로그를 취하고,\r\n\r\n$$\r\n\\begin{aligned}\r\n\\ln P(D|\\mu)\r\n=\r\n\\displaystyle\\sum_{n=1}^{N} \\ln \\mu + (1-x_n) \\ln(1-\\mu)\r\n\\end{aligned}\r\n$$\r\n\r\n$$\\mu$$에 대한 미분값이 0인 $$\\mu$$값(극대값)을 찾는 방식을 통해 다음과 같이 계산 할 수 있다.\r\n\r\n$$\r\n\\begin{aligned}\r\n\\cfrac d {d\\mu} \\ln P(D|\\mu)\r\n&=\r\n\\displaystyle\\sum_{n=1}^{N} x_n \\cfrac 1 \\mu - (1-x_n) \\cfrac 1 {1-\\mu}\r\n\r\n\\\\ &=\r\n\\cfrac 1 \\mu h - \\cfrac 1 {1-\\mu} t = 0\r\n\r\n\\end{aligned}\r\n$$\r\n\r\n따라서, MLE 방식으로 구한 $$\\mu$$ 값은 아래와 같다.\r\n\r\n$$\r\n\\begin{aligned}\r\n\\mu_{MLE} = \\cfrac h {t+h}\r\n\\end{aligned}\r\n$$\r\n\r\n결과적으로 MLE 방식으로 앞서 동전 던지기의 상황에 대한 파라미터 $$\\mu$$를 추정한다면, 앞면이 나온 횟수 $$h=2$$, 뒷면이 나온 횟수 $$t=1$$ 이기 때문에\r\n\r\n$$\r\n\\begin{aligned}\r\nP(H) = \\mu = \\cfrac 2 3\r\n\\end{aligned}\r\n$$\r\n\r\n이 되고, 이것은 맨 처음 가장 상식적으로? 동전의 앞면이 나올 확률을 예측한 것과 동일한 것을 알 수 있다.\r\n\r\n## Maximum a Posteriori (MAP)\r\n\r\n위 MLE 방식에는 맹점이 있다. 만약 동전을 여러번 던졌는데 그 결과가 아래와 같다면 어떨까?\r\n\r\n$$\r\n\\begin{aligned}\r\nT, T, T\r\n\\end{aligned}\r\n$$\r\n\r\n이런 상황이 발생한다면, MLE 방식으로 동전 앞면이 나올 확률, $$\\mu$$를 추정했을때는 0 이 될 것이다.\r\n이는 주어진 데이터의 불완정성으로 인해 모델 학습 과정에서 overfitting을 발생 시킬 소지가 있다는 것이다.\r\n\r\n이후 설명 할 MAP, 그리고 Bayesian 방식의 모델 파라미터 추정 방식은 이러한 문제를 방지하면서 좀 더 robust한 모델을 학습 하기 위한 철학이라고 생각하면 된다.\r\n\r\n> 사실 데이터가 충분히 많을 경우 위와 같은 문제는 거의 없다고 봐도 되지만, 현실 문제에 있어서 모든 현상을 완벽하게 설명하는 모델을 만들기 어렵고, 데이터 관점에서도 학습을 위해 구축되어 있는 데이터는 실제 우주에 존재하는 모든 관측 가능한 샘플 집합의 극히 일부분임을 감안할 때, 개인적으로는 가능하기만 하다면 Bayesian 방식의 접근법이 합리적이라고 생각한다.\r\n\r\nMAP 방식은 MLE 방식에 비해 조금 더 Bayesian스러운 방식이다.\r\n\r\n$$\\mu$$를 학습하기 위해 다음과 같은 식을 생각해보자.\r\n\r\n$$\r\n\\begin{aligned}\r\nPosterior &= \\cfrac {Likelihood \\times Prior} {Evidence}\r\n\r\n\\\\\r\n\r\nP(\\mu|D)\r\n&=\r\n\\cfrac {P(D|\\mu)P(\\mu)} {P(D)}\r\n\r\n\\\\ &\\propto\r\nP(D|\\mu)P(\\mu)\r\n\r\n\\end{aligned}\r\n$$\r\n\r\n<figcaption align=\"center\">\r\n  <b>식 2: Bayes' Rule</b>\r\n</figcaption>\r\n\r\n결론을 먼저 얘기하자면,\r\n\r\nMAP는 $$P(\\mu|D)$$, 즉 데이터 $$D$$가 주어졌을 때, 가장 그럴듯한 $$\\mu$$를 찾는 것을 목표로 하는 것이고, MAP에서는 point estimates, 다시 말하면 $$P(\\mu|D)$$의 극대값을 찾는 것을 말한다.\r\n\r\n$$\r\n\\begin{aligned}\r\n\\mu_{MAP} = \\argmax_{\\mu} P(\\mu|D)\r\n\\end{aligned}\r\n$$\r\n\r\n이때 $$P(\\mu|D)$$를 $$\\mu$$에 대한 사후 확률 분포(Posterior)라 하고, 이것은 식 2에서 처럼 베이즈 정리에 따라 가능도(Likelihood)와 사전 확률 분포(Prior)의 곱으로 표현할 수 있다.\r\n\r\n동전 던지기 상황에서 위 식을 적용한다면,\r\n\r\n$$P(D|\\mu)$$는 위 식 1 Likehood를, $$P(\\mu)$$는 베타 분포(Beta Distribution)를 사용하여 다음과 같이 정리할 수 있다.\r\n\r\n> 베르누이 분포의 conjugate prior인 베타분포를 이용하면 계산이 간편해 진다.\r\n\r\n$$\r\n\\begin{aligned}\r\nP(\\mu|D)\r\n&\\propto\r\nP(D|\\mu)P(\\mu)\r\n\\\\ &\\propto\r\n\\displaystyle\\prod_{n=1}^{N} \\mu^{x_n}(1-\\mu)^{1-x_n} \\cdot \\mu^{\\alpha-1}(1-\\mu)^{\\beta-1}\r\n\\\\ &\\propto\r\n\\mu^h(1-\\mu)^{t} \\cdot \\mu^{\\alpha-1}(1-\\mu)^{\\beta-1}\r\n\\\\ &\\propto\r\n\\mu^{h+\\alpha-1}(1-\\mu)^{t+\\beta-1}\r\n\\end{aligned}\r\n$$\r\n\r\n<figcaption align=\"center\">\r\n  <b>식 3: 동전 앞면이 나올 확률에 대한 사후 확률 분포</b>\r\n</figcaption>\r\n\r\n마찬가지로, \\mu의 극대값을 구하기위해 $$P(\\mu|D)$$ 식의 $$\\mu$$에 대한 미분값을 0으로 하여 계산하게 되면, 아래와 같은 결과를 얻을 수 있다.\r\n\r\n$$\r\n\\begin{aligned}\r\n\\mu_{MAP} = \\cfrac {h+\\alpha-1} {h+t+\\alpha+\\beta-2}\r\n\\end{aligned}\r\n$$\r\n\r\n이때, 동전 시행 횟수가 무한히 많아진다면, 위 식에서 상대적으로 작은 값인 $$\\alpha$$와 $$\\beta$$의 영향이 거의 없어지기 때문에, 위 값은 위 MLE 방식의 파라미터 추정값과 동일하게 된다고 볼 수 있다. MAP에서 사전 확률 분포를 Uniform Distribution으로 설정하면 이것은 MLE와 같은 결과를 얻을 수 있다.\r\n\r\n## Bayesian Inference\r\n\r\n위 MAP 방식은 어느정도 Bayesian 방식의 철학을 담고 있다고 하였다. 하지만 MAP로 추정한 파라미터 값 역시 point estimates이기 때문에 한계를 가진다.\r\n\r\n진정한 Bayesian 관점으로 파라미터를 추정하기 위해서는 더 많은 정보를 담고 있는 $$P(\\mu|D)$$ 분포를 이용하여 사후 확률 분포의 평균(Posterior mean)을 구하는 것이 필요하다. 즉, 모든 가능한 파라미터 셋팅에 대해 평균을 취하는 것이 가장 이상적인 선택이라는 뜻이다.\r\n\r\n$$\r\n\\begin{aligned}\r\n\\mathbb{E}(\\mu|D) = \\displaystyle\\int \\mu P(\\mu|D) d\\mu\r\n\\end{aligned}\r\n$$\r\n\r\n일반적으로 위 적분은 계산하기가 어려운 경우가 많아 특별한 inference 방식을 사용해야한다.\r\n\r\n> Gibbs Sampling 혹은 Variational Inference가 대표적이다.\r\n\r\n하지만, 위 식의 경우에는 굉장히 간단한 방법으로 계산을 할 수가 있는데, 앞서 설명 했듯이 $$P(\\mu|D)$$는 Likelihood가 베르누이 분포, Prior가 베타 분포로 형성된 Posterior 이다.\r\n\r\n베르누이 분포의 conjugate prior인 베타분포를 Prior로 둔 이유가 여기에 있는데, Likelihood와 Prior의 곱으로 표현되는 Posterior 역시 베타 분포로 그 형태가 동일하게 되기 때문에, $$P(\\mu|D)$$는 파라미터를 $$\\alpha+h$$, $$\\beta+t$$로 가지는 베타 분포이고, 이 베타분포의 기댓값이 바로 앞서 구하려고 했던 Posterior mean이라고 볼 수 있다.\r\n\r\n$$\r\n\\begin{aligned}\r\n\\mathbb{E}(\\mu|D)\r\n&= \\cfrac {\\alpha+h} {\\alpha+\\beta+h+t}\r\n\\\\ &= \\cfrac {\\alpha+h} {\\alpha+\\beta+N}\r\n\\end{aligned}\r\n$$\r\n","path":"00.research/bayesian-inference/coin-tossing","visitors":{"today":0,"total":55}},"__N_SSG":true}